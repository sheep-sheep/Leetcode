Backtracking is a way to solve computational problems, wwhich incremently build candiates and abandon partial candidate(from wiki).
I will analyze the core idea of each case and why it belongs to backtracking problem.

1. Print out all permutations of a list
  1) it needs to find sub permutations given one position/number
  2) as long as we do a swap, it's a valid case for partial solution(a permutation)
  3) when the case is valid, add this candidate to a res list
  
  class Solution(object):
      def permute(self, nums):
          """
          :type nums: List[int]
          :rtype: List[List[int]]
          """
          if len(nums) == 2:
              return [[nums[1], nums[0]], [nums[0], nums[1]]]
          elif len(nums) <= 2:
              return [nums]
          else:
              count = 0
              tmp = []
              for num in nums:
                  for candidate in self.permute(nums[0:count]+nums[count+1:]):
                      tmp.append([num]+candidate)
                  count +=1
              return tmp
          return self.permute(nums)

It seems this still not the standard backtracking pattern, i will edit it later.

2. When the permutation has duplicate
  Just skip the element when we found it appears before(here we will have multiple ways to handle)
  
3. 
