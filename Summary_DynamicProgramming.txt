# Note of Introduction to Algorithm
Dynamic Programming is a special form of divide and conquer method, it's very useful when the subproblems overlap each other.
By using a tabular method, it stores the computed result to accelerate the computation.

DP can be used to find an optimal solution(min or max) or the value of an optimal solution.

There're 4 steps to construct a solution to DP problems:
    1. Characterize the structure of an optimal solution(How to represent the problem using "last step" and "subproblem")
    2. Recursively build the value of an optimal solution(How to use a function to build the relationship)
    3. Compute the value of setp 2 typically in a bottom-up fashion(Initial Value[0, INF])
    4. Construct the solution from computed information(Bottom up)


Arrange foreach subproblem to be solved only once, saving its solution. It servers an example of a time-meory trade-off.

1. top down with memoization:need an auxiliary array and a helper routine.
    O(n*n): an n loop with overal all recurisve calls which is an arithmetic serie.
   we can view it as DFS search of the subproblem graph.
   
2. bottom up: natural ordering of the sub-problem.
    O(n*n): double for loops and forms arithmetic series.
    
How do we constructe the actual solutionï¼Ÿ 
Just add another array to keep the optimal solution at current position and return both Aux and AuxSol to caller.



def fib(n):
    if n<=1: return 1
    return fib(n-2) + fib(n-1)


helpMap = {0: 0,
           1: 1}
def fib_dp_topdown(n):
    if n not in helpMap.keys():
        helpMap[n] = fib_dp_topdown(n-1) + fib_dp_topdown(n-2)
    return helpMap[n]


def fib_dp_bottomup(n):
    if n == 0:
        return 0
    else:
        prevVal, currVal = 0, 1
        for _ in range(n):
            fib = prevVal + currVal
            prevVal = currVal
            currVal = fib
    return currVal


Coin Change problem:
# We note that this problem has an optimal substructure property, which is the key piece 
# in solving any Dynamic Programming problems. In other words, the optimal solution can 
# be constructed from optimal solutions of its subproblems.     

# This is a bottom-up approach
# Top-down approach is to apply memoziation to the recursive call
class Solution(object):
    def coinChange(self, coins, amount):
        inf = float('inf')
        dp = [0]+[inf]*amount # initial edge case 0 is for construct the following values.
        for i in range(1, amount+1):
            dp[i] = min(dp[i-coin]+1 if (i-coin)>=0 else inf for coin in coins)
        return dp[-1] if dp[amount]!=inf else -1
        
Similar solution:
70 Climbing Stairs: it can use both bottom up and top down method
62 Unique Path: it build the table for all possible paths
63 Unique Path II: just skip the obstacles
Rod Cutting problem
Matrix-chain multiplication
    Find the order to do fully parenthezied matrix multiplication which will have the lowest cost.

Maximum Subarray:
this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem). 

Edit Distance:
    1. Similar to Maximum Subarray, we have to define a boundry to help us solve the problem easily.
    2. dp[i][j] is the pattern for most of the DP problem
    3. When you finish the abstraction, don't think about the detail, you have to relate the abstraction to the solution, not to the detail case
    4. Prepare a base case, which is 0 or i or j.
    5. the final format will be very easy.
    
Possible DP questions:
1. Count of solutions
2. Find the MAX or MIN
3. Optimal solution for one game(Existence)
4. Unituqe Paths
5. Jump game
