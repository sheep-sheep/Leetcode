# Note of Introduction to Algorithm
Dynamic Programming is a special form of divide and conquer method, it's very useful when the subproblems overlap each other.
By using a tabular method, it stores the computed result to accelerate the computation.

DP can be used to find an optimal solution(min or max) or the value of an optimal solution.

There're 4 steps to construct a solution to DP problems:
    1. Characterize the structure of an optimal solution
    2. Recursively build the value of an optimal solution
    3. Compute the value of setp 2 typically in a bottom-up fashion
    4. Construct the solution from computed information

def fib(n):
    if n<=1: return 1
    return fib(n-2) + fib(n-1)


helpMap = {0: 0,
           1: 1}
def fib_dp_topdown(n):
    if n not in helpMap.keys():
        helpMap[n] = fib_dp_topdown(n-1) + fib_dp_topdown(n-2)
    return helpMap[n]


def fib_dp_bottomup(n):
    if n == 0:
        return 0
    else:
        prevVal, currVal = 0, 1
        for _ in range(n):
            fib = prevVal + currVal
            prevVal = currVal
            currVal = fib
    return currVal


Similar solution:
70 Climbing Stairs: it can use both bottom up and top down method
62 Unique Path: it build the table for all possible paths
63 Unique Path II: just skip the obstacles
